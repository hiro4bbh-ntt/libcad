//! The syntax of the LLIR interpreter.

use super::ValView;
use crate::fmt::DisplayIter;
use crate::llir::interp::rtti::ExtIdent;
use crate::llir::parser::Parser as LLIRParser;
use crate::llir::syntax::{
    Blocks, FuncDecl, GlobalIdent, Insn, Label, Loc, LocalIdent, Stmt, Type as LLIRType, Typedefs,
};
use std::fmt;

/// An error generated by an interpreter.
#[derive(Clone, Debug)]
pub enum Error {
    AddrNotFound(Addr),
    AlreadyStarted(Loc),
    ArgsUnmatched(GlobalIdent, usize, usize),
    BinOp(String),
    BitcastPoison(Addr, LLIRType<ExtIdent>),
    Callee(Val),
    CastAs(ValView, LLIRType<ExtIdent>),
    CmpOp(String),
    CollapsePoison(LLIRType<ExtIdent>, Addr),
    Deref(Addr),
    DerefPoison(Addr, i64),
    EmptyStack,
    EntryBlockNotFound(GlobalIdent),
    Finished(Option<Val>),
    FuncNotFound(GlobalIdent),
    Getelementptr(String),
    GlobalNotFound(GlobalIdent),
    InsnNotFound(Loc),
    LoadFrom(Val),
    LocalNotFound(LocalIdent),
    MalformedValue(String),
    MallocSize(i64),
    NotStarted,
    OutOfBoundInRegion(ValView),
    OutOfBoundInVal(Val, i64),
    OverflowSignedIntAdd(usize, i64, i64),
    PoisonSizeUnmatched(LLIRType<ExtIdent>, i64, Addr),
    ReadInt(ValView, i64),
    RedefineGlobal(GlobalIdent),
    RetValExpected(LocalIdent),
    RetValUnexpected(Val),
    StoreTarget(LLIRType<ExtIdent>),
    StoreTo(Val),
    TryTo(ValView, LLIRType<ExtIdent>),
    TypeNotFound(LLIRType<ExtIdent>),
    Unsupported(String),
    UseAfterFree(Addr),
    WriteConst(ValView, Const),
    WriteInt(ValView, i64),
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        match self {
            Error::AddrNotFound(addr) => write!(f, "addr {} is not found", addr),
            Error::AlreadyStarted(loc) => write!(f, "already started and at {}", loc),
            Error::ArgsUnmatched(funcname, expected, got) => write!(
                f,
                "func {} expected {} arg(s), but got {} arg(s)",
                funcname, expected, got
            ),
            Error::BinOp(msg) => write!(f, "{}", msg),
            Error::BitcastPoison(addr, ty) => {
                write!(f, "cannot bitcast poison at addr {} to {}", addr, ty)
            }
            Error::Callee(v) => write!(f, "cannot call {}", v),
            Error::CastAs(view, ty) => write!(f, "cannot cast {} as {}", view, ty),
            Error::CmpOp(msg) => write!(f, "{}", msg),
            Error::CollapsePoison(ty, addr) => {
                write!(f, "cannot collapse poison with type {} at {}", ty, addr)
            }
            Error::Deref(addr) => write!(f, "cannot deref addr {}", addr),
            Error::DerefPoison(addr, size) => write!(
                f,
                "cannot deref addr {} containing poison with size {}",
                addr, size
            ),
            Error::EmptyStack => write!(f, "stack is empty"),
            Error::EntryBlockNotFound(funcname) => {
                write!(f, "entry block not found in func {}", funcname)
            }
            Error::Finished(None) => write!(f, "terminated with no result"),
            Error::Finished(Some(v)) => write!(f, "terminated with result {}", v),
            Error::FuncNotFound(name) => write!(f, "func {} not found", name),
            Error::Getelementptr(msg) => write!(f, "{}", msg),
            Error::GlobalNotFound(name) => write!(f, "{} is not found", name),
            Error::InsnNotFound(loc) => write!(f, "insn{} not found", loc),
            Error::LoadFrom(v) => write!(f, "cannot load value from {}", v),
            Error::LocalNotFound(name) => write!(f, "{} is not found", name),
            Error::MalformedValue(msg) => write!(f, "{}", msg),
            Error::MallocSize(size) => write!(f, "illegal malloc size {}", size),
            Error::NotStarted => write!(f, "not started"),
            Error::OutOfBoundInRegion(view) => {
                write!(f, "{} is out-of-bound in region", view)
            }
            Error::OutOfBoundInVal(v, size) => {
                write!(f, "size {} is out-of-bound in value {}", size, v)
            }
            Error::OverflowSignedIntAdd(w, x1, x2) => {
                write!(f, "overflow add i{} {}, {}", w, x1, x2)
            }
            Error::PoisonSizeUnmatched(ty, size, addr) => write!(
                f,
                "type {} unmatches poison with size {} at {}",
                ty, size, addr
            ),
            Error::ReadInt(view, n) => {
                write!(f, "cannot read i{} value at {}", n, view)
            }
            Error::RedefineGlobal(name) => write!(f, "cannot redefine {}", name),
            Error::RetValExpected(name) => write!(f, "expected returned value in {}", name),
            Error::RetValUnexpected(v) => write!(f, "unexpected returned value {}", v),
            Error::StoreTarget(ty) => write!(f, "illegal store target type {}", ty),
            Error::StoreTo(v) => write!(f, "cannot store value to {}", v),
            Error::TryTo(view, ty) => {
                write!(f, "cannot convert {} to value with type {}", view, ty)
            }
            Error::TypeNotFound(ty) => write!(f, "type {} not found", ty),
            Error::Unsupported(msg) => write!(f, "{}", msg),
            Error::UseAfterFree(addr) => write!(f, "cannot use {} after free", addr),
            Error::WriteConst(view, c) => write!(f, "cannot write {} with {}", view, c),
            Error::WriteInt(view, n) => {
                write!(f, "cannot write i{} value at {}", n, view)
            }
        }
    }
}

/// A region of [`Addr`].
#[derive(Clone, Debug)]
pub enum Region {
    /// `null`.
    Null,
    /// A global function.
    GlobalFunc(GlobalIdent),
    /// A region allocated in stack.
    Alloca(usize),
    /// A region allocated in heap.
    Heap(usize),
}

impl fmt::Display for Region {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        match self {
            Region::Null => write!(f, "null"),
            Region::GlobalFunc(name) => write!(f, "{}", name),
            Region::Alloca(id) => write!(f, "alloca#{}", id),
            Region::Heap(id) => write!(f, "heap#{}", id),
        }
    }
}

/// An address that is a pair of region and offset.
#[derive(Clone, Debug)]
pub struct Addr {
    pub region: Region,
    pub offset: i64,
}

impl Addr {
    /// Returns a new address whose offset is replaced.
    pub fn rebase(&self, offset: i64) -> Addr {
        Addr {
            region: self.region.clone(),
            offset,
        }
    }
}

impl fmt::Display for Addr {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        write!(f, "{}{:+}", self.region, self.offset)
    }
}

/// A constant.
#[derive(Clone, Debug)]
pub enum Const {
    /// An 1-bit (signed) integer with the domain mask.
    I1(bool, bool),
    /// An 8-bit (signed) integer with the domain mask.
    I8(i8, u8),
    /// A 16-bit (signed) integer with the domain mask.
    I16(i16, u16),
    /// A 32-bit (signed) integer with the domain mask.
    I32(i32, u32),
    /// A 64-bit (signed) integer with the domain mask.
    I64(i64, u64),
    /// A 32-bit IEEE 754 floating number with defined flag.
    Float(Option<f32>),
    /// A 64-bit IEEE 754 floating number with defined flag.
    Double(Option<f64>),
    /// An address with the defined flag.
    Addr(Option<Addr>),
    /// A padding region with size in byte.
    Pad(i64),
}

impl Const {
    /// Returns the alignment in byte.
    pub fn align(&self) -> i64 {
        match self {
            Const::I1(..) => 1,
            Const::I8(..) => 1,
            Const::I16(..) => 2,
            Const::I32(..) => 4,
            Const::I64(..) => 8,
            Const::Float(_) => 4,
            Const::Double(_) => 8,
            Const::Addr(_) => 8,
            Const::Pad(_) => 1,
        }
    }
    /// Returns the size in byte.
    pub fn size(&self) -> i64 {
        match self {
            Const::I1(..) => 1,
            Const::I8(..) => 1,
            Const::I16(..) => 2,
            Const::I32(..) => 4,
            Const::I64(..) => 8,
            Const::Float(_) => 4,
            Const::Double(_) => 8,
            Const::Addr(_) => 8,
            Const::Pad(n) => *n,
        }
    }
    /// Returns the casted 64-bit integer.
    pub fn try_to_i64(&self) -> Result<i64, Error> {
        match self {
            Const::I1(false, true) => Ok(0),
            Const::I1(true, true) => Ok(1),
            Const::I8(n, m) if *m == !0 => Ok(*n as i64),
            Const::I16(n, m) if *m == !0 => Ok(*n as i64),
            Const::I32(n, m) if *m == !0 => Ok(*n as i64),
            Const::I64(n, m) if *m == !0 => Ok(*n),
            _ => Err(Error::TryTo(
                Val::from(self.clone()).into_view(0),
                LLIRType::I64,
            )),
        }
    }
}

impl fmt::Display for Const {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        match self {
            Const::I1(b, true) => write!(f, "i1 {}", b),
            Const::I1(_, false) => write!(f, "i1 undef"),
            Const::I8(n, m) if *m == !0 => write!(f, "i8 {}", n),
            Const::I8(n, m) => write!(f, "i8 undef@{:#04x}({})", !m, n),
            Const::I16(n, m) if *m == !0 => write!(f, "i16 {}", n),
            Const::I16(n, m) => write!(f, "i16 undef@{:#06x}({})", !m, n),
            Const::I32(n, m) if *m == !0 => write!(f, "i32 {}", n),
            Const::I32(n, m) => write!(f, "i32 undef@{:#010x}({})", !m, n),
            Const::I64(n, m) if *m == !0 => write!(f, "i64 {}", n),
            Const::I64(n, m) => write!(f, "i64 undef@{:#018x}({})", !m, n),
            Const::Float(Some(n)) => write!(f, "float {}", n),
            Const::Float(None) => write!(f, "float undef"),
            Const::Double(Some(n)) => write!(f, "double {}", n),
            Const::Double(None) => write!(f, "double undef"),
            Const::Addr(Some(addr)) => write!(f, "{}", addr),
            Const::Addr(None) => write!(f, "void* undef"),
            Const::Pad(n) => write!(f, "!pad {}", n),
        }
    }
}

/// A value that is the sequence of constants.
#[derive(Clone, Debug)]
pub struct Val(Vec<Const>);

impl Val {
    /// Returns a new empty value.
    pub fn empty() -> Val {
        Val(Vec::new())
    }
    /// Returns a new value.
    pub fn new(fields: Vec<Const>) -> Val {
        Val(fields)
    }
    /// Returns a new undefined value with the given type.
    pub fn undef(ty: &LLIRType<ExtIdent>, typedefs: &Typedefs<ExtIdent>) -> Result<Val, Error> {
        let mut view = ValView::empty();
        view.push_undef(ty, false, typedefs)?;
        Ok(view.into_val())
    }
    /// Returns the length.
    pub fn len(&self) -> usize {
        self.0.len()
    }
    /// Returns `true` if empty.
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    /// Returns an iterator.
    pub fn iter(&self) -> impl Iterator<Item = &Const> {
        self.0.iter()
    }
    /// Returns the constant.
    pub fn get(&self, i: usize) -> Option<&Const> {
        self.0.get(i)
    }
    /// Returns the constant as mutable.
    pub fn get_mut(&mut self, i: usize) -> Option<&mut Const> {
        self.0.get_mut(i)
    }
    /// Pushes the constant.
    pub fn push(&mut self, c: Const) {
        self.0.push(c)
    }
    /// Returns the alignment in byte.
    pub fn align(&self) -> i64 {
        match self.get(0) {
            Some(c) => c.align(),
            None => 1,
        }
    }
    /// Returns the size in byte.
    pub fn size(&self) -> i64 {
        let mut size = 0;
        for c in self.iter() {
            size += c.size();
        }
        size
    }
    /// Returns the casted 64-bit integer.
    pub fn try_to_i64(&self) -> Result<i64, Error> {
        match self.get(0) {
            Some(c) => c.try_to_i64(),
            None => Err(Error::TryTo(self.clone().into_view(0), LLIRType::I64)),
        }
    }
    /// Returns the view on the value with the given offset.
    pub fn into_view(self, offset: i64) -> ValView {
        ValView {
            size: self.size(),
            val: self,
            offset,
            pad: false,
        }
    }
}

impl From<Const> for Val {
    fn from(c: Const) -> Val {
        Val(vec![c])
    }
}

impl fmt::Display for Val {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        write!(f, "{}", DisplayIter("<", self.0.iter(), ", ", ">"))
    }
}

impl IntoIterator for Val {
    type Item = Const;
    type IntoIter = std::vec::IntoIter<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

/// A function that is the tuple of name, arguments and blocks.
#[derive(Clone, Debug)]
pub struct Func {
    name: GlobalIdent,
    args: Vec<LocalIdent>,
    blocks: Blocks<ExtIdent>,
}

impl Func {
    /// Returns a new function.
    pub fn new(name: GlobalIdent, args: Vec<LocalIdent>, blocks: Blocks<ExtIdent>) -> Func {
        Func { name, args, blocks }
    }
    /// Returns a new function from the declaration.
    pub fn new_with_funcdecl(decl: FuncDecl<ExtIdent>, blocks: Blocks<ExtIdent>) -> Func {
        Func {
            name: decl.sig.expect_name(),
            args: decl.sig.argnames(),
            blocks,
        }
    }
    /// Returns a parsed function from the given source text in LLIR representation.
    pub fn try_parse(source: &str) -> Result<Func, String> {
        match LLIRParser::try_new_stmt(source)? {
            Some((Stmt::Func(decl, blocks), _)) => Ok(Func::new_with_funcdecl(decl, blocks)),
            _ => Err(format!("expected func stmt in {}", source)),
        }
    }
    /// Returns a parsed function from the given source text in LLIR representation.
    pub fn parse(source: &str) -> Func {
        Func::try_parse(source).expect(source)
    }
    /// Returns the name.
    pub fn name(&self) -> GlobalIdent {
        self.name
    }
    /// Returns the arguments.
    pub fn args(&self) -> &[LocalIdent] {
        &self.args
    }
    /// Returns the name of the entry block.
    pub fn entryname(&self) -> Result<Label, Error> {
        match self.blocks.get(0) {
            Some(block) => Ok(block.name),
            None => Err(Error::EntryBlockNotFound(self.name)),
        }
    }
    /// Returns the instruction at the location.
    pub fn insn(&self, blockname: &Label, insnidx: usize) -> Result<&Insn<ExtIdent>, Error> {
        for block in self.blocks.iter() {
            if &block.name == blockname {
                if let Some(insn) = block.insns.get(insnidx) {
                    return Ok(insn);
                }
            }
        }
        Err(Error::InsnNotFound(Loc::new(
            self.name, *blockname, insnidx,
        )))
    }
}

/// A continuation representing control flow update.
#[derive(Clone, Debug)]
pub enum Cont {
    /// Call of function with arguments.
    /// If the local variable is defined, the result is stored to it.
    Call(Option<LocalIdent>, GlobalIdent, Vec<Val>),
    /// Jump to the label.
    Goto(Label),
    /// Return the value.
    Ret(Option<Val>),
}

impl fmt::Display for Cont {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        match self {
            Cont::Call(res, name, args) => {
                write!(f, "call(")?;
                match res {
                    Some(res) => write!(f, "{}", res)?,
                    None => write!(f, "none")?,
                }
                write!(
                    f,
                    ", {}, {})",
                    name,
                    DisplayIter("[", args.iter(), ", ", "]")
                )
            }
            Cont::Goto(label) => write!(f, "goto({})", label),
            Cont::Ret(None) => write!(f, "ret()"),
            Cont::Ret(Some(v)) => write!(f, "ret({})", v),
        }
    }
}

/// An effect representing control flow or heap update.
#[derive(Clone, Debug)]
pub enum Effect {
    /// Allocate on the stack with the value, and the pointer is stored to the local variable.
    Alloca(LocalIdent, Val),
    /// Collapse the poisoned value, and the pointer is stored to the local variable.
    CollapsePoison(LocalIdent, Addr, LLIRType<ExtIdent>),
    /// Update control flow.
    Cont(Cont),
    /// Skip the debug intrinsic.
    DbgIntr(GlobalIdent),
    /// Allocate on the heap with the size, and the poisoned value is stored to the local variable.
    Malloc(LocalIdent, i64),
    /// Store the value to the local variable.
    SetLocal(LocalIdent, Val),
    /// Store the value to the region.
    StoreTo(Val, Region),
}

impl fmt::Display for Effect {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        match self {
            Effect::Alloca(name, val) => write!(f, "alloca({}, {})", name, val),
            Effect::CollapsePoison(name, addr, ty) => {
                write!(f, "collapse-poison({}, {}, {})", name, addr, ty)
            }
            Effect::Cont(cont) => write!(f, "{}", cont),
            Effect::DbgIntr(name) => write!(f, "dbgintr({})", name),
            Effect::Malloc(name, size) => write!(f, "malloc({}, {})", name, size),
            Effect::SetLocal(name, val) => write!(f, "define-local({}, {})", name, val),
            Effect::StoreTo(v, region) => write!(f, "store-to({}, {})", v, region),
        }
    }
}

/// A value that may be poisoned.
#[derive(Clone, Debug)]
pub enum PoisonVal {
    /// A poisoned value with size.
    Poison(i64),
    /// A (non-poisoned) value.
    Val(Val),
}

/// A state of an interpreter.
#[derive(Clone, Debug)]
pub enum State {
    /// The interpreter is not started.
    NotStarted,
    /// The instruction pointer of the interpreter is at the location.
    At(Loc),
    /// The interpreter is finished with the value.
    Finished(Option<Val>),
}

impl fmt::Display for State {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        match self {
            State::NotStarted => write!(f, "not-started"),
            State::At(loc) => write!(f, "at({})", loc),
            State::Finished(None) => write!(f, "finished()"),
            State::Finished(Some(v)) => write!(f, "finished({})", v),
        }
    }
}

impl State {
    /// Returns the location.
    pub fn loc(&self) -> Result<Loc, Error> {
        match self {
            State::NotStarted => Err(Error::NotStarted),
            State::At(loc) => Ok(*loc),
            State::Finished(res) => Err(Error::Finished(res.clone())),
        }
    }
    /// Steps the state.
    pub fn step(&mut self) -> Result<(), Error> {
        match self {
            State::NotStarted => Err(Error::NotStarted),
            State::At(loc) => {
                loc.insnidx += 1;
                Ok(())
            }
            State::Finished(res) => Err(Error::Finished(res.clone())),
        }
    }
    /// Jumps the state to the block.
    pub fn goto(&mut self, blockname: Label) -> Result<(), Error> {
        match self {
            State::NotStarted => Err(Error::NotStarted),
            State::At(loc) => {
                *loc = Loc::new(loc.func, blockname, 0);
                Ok(())
            }
            State::Finished(res) => Err(Error::Finished(res.clone())),
        }
    }
}
